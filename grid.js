Grids are two-dimensional. I can place things on it horizontally vertically and both simultaneously. Actually I can position items in any way I want, even stacked. Each number represents a line. These lines are row lines and these lines are column lines. Our grid is made up of cells. Each square is a cell. And finally our grid is also made up of tracks. These are the rows and these are the columns. Creating a grid starts in the HTML, we need a container and some items inside of it. The container is a div with the class of container and the items are divs with the class of item, item-1, 2, and 3. In our CSS, we give the container the display of grid. We see nothing happened but this is because we need to tell grid how many rows and columns we want to find. To Define rows and columns, we use the grid-template-rows and grid-template-columns properties. They work by defining a track for each value that you pass it. If I give 100 pixels to the columns. Now I have one column of 100 pixels. If I add a second value of 100 pixels. Now I have two columns of 100 pixels and so on. I'll copy the values from my grid-template-columns and paste them in the grid-template-rows. Now I have a grid with six rows and six columns and all of the cells have the same size. If I want to position an item, I can select it and give it the grid-row-start, grid-row-end, grid-column-start, grid-column-end properties inside of each item. We'll go some line numbers. Let's say, I want item-1 to look like this. Then that means item-1 starts on line 1 of both the rows and the columns. We also see that item-1 ends on the third line of the rows and ends on the fifth line of the columns. The other two items were pushed because we aren't explicitly defining their position. Writing these four properties each time, you want to position something is a bit much. You can instead use these two shorthand properties grid-row and grid-column. Like the other properties, these also take inline numbers as values. The first value is the starting line. The second is the ending line. And they need to be separated by a slash. I want my second item to span two rows and columns. I could give it a grid-row of one and 1/3 and a grid-column of 5/7. And this works amazingly but an easier way to achieve this is with this span keyword. Instead of the values that I currently have, I can just use this span keyword with the number of cells that I want to span. Basically, this span keyword is saying from wherever you currently are span yourself this number of times. This is easy to read and is also why a lot of people love this span keyword. But the main downfall of using this is it doesn't allow you to explicitly define your starting and ending position. And as a consequence, our item will be pushed away if I increase the size of a nearby item like item-1. If you don't care about anchoring an item into a specific position, then this span keyword is okay to use. Using grid-row and grid-column is good but there's an even faster property grid-area. Takes four values the first is the starting line on the rows. The second is the starting line on the columns. The third is the ending line on the rows and the fourth is the ending line on the columns. If I want item-3 to fill out the rest of the available space, I can give it the grid-area with the starting row of three, the ending column of 1, the ending row of 7 and the ending column of 7. I can also use the negative numbers that we see on our grid. So instead of row 7 and column 7, I could say -1 and -1 and this will work the same. This one property does the job of six properties. So personally that's the one that I always use. Before CSS grid, layering an item on top of another was painful. You had to use an absolute positioning and then try to position the item using the top, right, bottom and left properties. But with CSS grid, you just position your item where you want it to be and if that happens to be on top of another item then that creates layering super easy. I want item-2 to be right here touching both the item-1 and item-3. To do this, I'll remove the grid-row and grid-column and use the grid-area instead. The row starts at two. The column starts at four. The row ends at four and the column ends at six. Our item needs to be on top. All we have to do is give it a z-index of one and now item-2 is layered on top of both item-1 and item-3. Now we see our items are filling out all of the available space except maybe for the top right corner. I'll make item-1 span all of the columns just to fill everything up. So now that all the cells are occupied. What would happen, if I added another item in our HTML. Despite not having any room left, our grid added a new row for item-4. When items are added outside of the explicitly defined grid. This is referred to as an implicit grid. Notice how item-4 is smaller than the others. That's because the implicit grid doesn't inherit the values that we set in the grid-template-rows and grid-template-columns properties. But what we can do is add the grid-auto-rows property on our container. What this does is sets the size of the rows on any implicit grid that gets created. When I set it to 100 pixels. Now our implicit grid has a row of 100 pixels. By default, our implicit grid added a row. But we can change this with the grid-auto-flow property and set it to column. Now any implicit grid that gets created will be created as a column instead. With the columns being the new default for our implicit grids, we can use grid-auto-columns to define the size of this columns and set it to 100 pixels. Now, let's reset our grid by commenting out almost everything except the grid-template-rows and grid-template-columns. Inside the grid-template-rows and grid-template-columns, we can go more than just pixel units. You can use em, rem, percentages, etc. But there is one called the fractional unit that you should know about. I'm going to give the rows two values of 100 pixels and I'll give the columns three values of one fr. The fr unit represents a fractional value of the available space. And now we've got three columns each and filling out the available space equally. If I set the item-2 fr to 2 or 3, we see the column occupying more of the available space. You can also mix the fr units with other units without any issues. So, for example, I can make the item-1 value be 100 pixels. In general, you can mix and match values without any problems. When I resize the page, some of the items get way too thin. To set a minimum width, we can use the minmax function inside our grid-template-columns. I'll use the minmax function on the second column. It takes two arguments. The first is the minimum size and the second is the maximum size. I'll set the minimum size to 100 pixels and the maximum size to 3fr. Now, our item will stop shrinking whenever it hits 100 pixels. Another useful function is the repeat function. I'll use this one on my grid-template-rows. The way the repeat function works is by taking two arguments. The first argument is the number of times you want to repeat a value and the second argument is the value you want to have repeated. We had two values of 100 pixels. So I'll set the first argument to 2 and the second argument to 100 pixels. Now the rows are just like they were before two rows of 100 pixels. But now at least we aren't repeating ourselves. We can also add gaps to our grid with the grid-gap property. If you assign it one value, then it will add gaps equally to both the rows and the columns. If you assign it two values, the first is the gaps on the rows and the second value is the gaps on the columns. I'm going to replace the values in my grid-template-rows for 100 pixels, 300 pixels and 100 pixels. I'll also replace the values inside my grid-template-columns for 1fr and 3fr. I'm going to show you another way of positioning items in your grid that doesn't require keeping track of the line numbers in my container. I'll add the grid-template-areas property. As a value, I'll give it three sets of single quotes stacked on top of one another with a semicolon. After the last set of single quotes, looking at my grid-template-rows. I see I defined three rows and looking at my grid-template-columns. I see I defined two columns. We have three rows and two columns. Well inside the first set of single quotes, I'll say header and header. Inside the second set of single quotes, I'll say main and aside inside the third set of single quotes. I'll say footer and footer. The reason I added three sets of single quotes is because I know my grid only has three rows and the reason I added two values inside of each of the single quotes is because I know my grid only has two columns. Each set of single quotes represents a row and each value inside of them represents a column. Looking at my grid, we see the developer tools added the names we set inside the grid-template-areas in the appropriate position. Now all I have to do is give each item the grid-area property and assign them the section I want them to occupy. I want item-1 to be the header. I want item-2 to be the main. I want item-3 to be the aside and I want item-4 to be the footer. Now we see each item is occupying the section we assign them to be. The way this was just an example. I don't think I'd have one grid for all four sections. In a real website, I'd probably have multiple different grids across my page for the various sections and components also. This way of positioning things is fun but it makes layering items more difficult. It can be done though it's just more difficult. We're almost done. I'll reset my grid by commenting out pretty much everything and set a repeat of four 100 pixels on the rows and a repeat of 4 1fr on the columns. Our items are currently stretching both on the row axis and the column axis. And this is because on our container, there's two properties. We don't currently have but that in the background have a default of stretch. The justify-items and the Align-items properties both have a default value of stretch. I can change them to either start and baseline or center. Justify-items, align-items on the row axis. So if I change it justify-items to anything else like start, we see our items are at the start of the row axis but still in the center of the column axis. If I change align-items to anything else like end, now our items are still at the start of the row axis but are now at the end of the column axis. These properties are affecting all of the items. But if we wanted to align-items individually, we can use the justify-self and the align-self properties on the items themselves. So, for example, if I wanted to overwrite the row alignment of item-1, I could use the justify-self and set it to anything else like center. And if I wanted to also overwrite the column alignment, I would use the align-self property, maybe this one I'll set it to stretch. Justify-items and align-items are used to align our items inside our grid. But we can also align the grid itself along the container. So, for example, I'll clean things up by removing everything except grid-template-rows and grid-template-columns. I'll also add a height to the container of 600 pixels. I'll say that we have two rows instead of four and also two columns instead of four. I'll also replace the 1fr with 100 pixels. Now we have a smaller Grid in comparison to The Container we can align the grid with justify-content and align-content. They both take the same values start and center, baseline, space-between, space-around and space-evenly. Justify-content aligns the grid along the row axis and align-content aligns the grid along the column axis. The last thing I want to show you is a cool trick for creating a responsive grid that requires zero media queries that's right responsive without media queries. Once more, I'll reset my grid. I'll set up a standard grid. The grid-template-rows can have a repeat of four 100 pixels and the grid-template-columns can have a repeat of four and a minmax of 100 pixels and one fr. If I resize it, it'll eventually break. To fix this normally, I would add a media query and change things based off the viewport width. But instead of all, I can do this in my grid-template-columns. Instead of repeating four times, I can replace four with the autofit keyword. Now when the items reach their minimum size of 100 pixels, the autofit keyword will make the items autofit and wrap onto the next row. Creating a grid that is automatically responsive.  

